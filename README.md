# Pyli: A lightweight API Gateway written in Go

## Table of contents

1. [Introduction](#introduction)
2. [Api Gateway Components](#api-gateway-components)

## Introduction
This is a lightweight API Gateway written in Go, supporting route registration, request proxying, rate limiting, and JWT-based authentication. It’s a toy project built to explore the fundamentals of API gateway design. The gateway is configured through a `config.yaml` file, loaded on startup, which defines key settings such as the listening port, registered routes with their corresponding endpoints, request rate limits, etc.

## Api Gateway Components
An API Gateway is a software component that acts as a single entry point or a "front desk" for client applications to access backend services or APIs. It simplifies communication between clients and services by handling tasks such as:

1. **Routing requests** – forwarding incoming requests to the appropriate backend service based on routing rules.

2. **Authentication and authorization** – ensuring only authenticated and authorized clients can access protected resources.

3. **Rate limiting and throttling** – managing the rate of client requests to prevent overloading backend services.

The API Gateway diagram below, illustrates the architecture of this project which is composed of three major elements: Middleware, Routes, and Handlers.

Incoming requests are first processed by the Middleware components. These components check whether the request is authenticated and whether the originating client has not exceeded the allowed request limit. If the request passes these checks, it is forwarded to the Routes component, which determines the appropriate destination service.

Each route is associated with a specific Handler. For example, a request to the path `/api/dummy/test` may be forwarded through a proxy to Service B. The response generated by the service is then sent back through the proxy and ultimately returned to the client.

![api-gateway](./assets/api-gateway.png)
1. **Middleware**
    1. **Rate Limiter**: This component follows the Token Bucket algorithm. The idea behind the Token Bucket is that we maintain a bucket with a fixed capacity, which is refilled with tokens at regular intervals (e.g., every minute or hour). Each incoming request requires a token: if a token is available, the request is allowed; if not, the request is rejected until tokens are replenished.
    In our implementation, we use a map to track clients by their IP addresses. Each client is assigned a separate bucket with a capacity of 5 tokens.
    ![rate-limiter](./assets/rate-limiter.png)
    2. **Authentication**: This component verifies whether the client has included a valid JSON Web Token (JWT) in the request’s `X-Access-Token` header (alternatively we could use the `Authorisation` header). If the token is missing or invalid, the request is rejected with an HTTP 401 Unauthorized status.
2. **Routes**
    1. Protected Routes - `/api/dummy/test`
    2. Unprotected Routes - `/api/login`
3. **Handlers**
    1. JWT Authentication: Initially the user reach the `/api/login` route, to request a JWT (JSON Web Token). The server creates a token, signs it, and sends it to the client. The client stores the token and includes it in the subsequent request headers to access protected routes. The server then verifies the token’s signature and validity; if valid, the request proceeds, otherwise it’s rejected.
    ![jwt](./assets/jwt.png)
    2. **Proxy**: For each route, there is a dedicated Proxy that forwards requests to the corresponding backend service, as defined in the `config.yaml` file. The Proxy component can also modify service responses when needed and gracefully handle errors, such as service unavailability.
